# Programming with R

<!-- Aim of this is to show people how they can include programing features to enhance their coding. Mostly tips and shit to get them started no encompasing guide --> 

Programming is writing instructions that tell the computer what to do. Like most things, learning a little goes a long way. And like most things, it's easy to lose the forest for the trees. That's why we won't focus too much on programming (after all you're chemist not computer scientist) but we will introduce a few simple yet incredibly powerful elements of programming to help you along with your data science quest.

We'll point to several sources for further reading on functions at the end of this chapter. 


- Functions: how to make them, and why they’re useful 
  - Conditional execution (if, else) 
  - Arguments 
- Iterating 
  - For loops 
  - Talk about vectors 
  - When it’s useful, etc.

## Functions  
  
Functions allow you to write general purpose code to automate common tasks. They're a great way to decrease repetition and make your code more legible and reproducible. To crease a function in R you only need `function()`:

```{r}
funSum <- function(x,y){
  z <- x + y
  paste("The sum of", x, "+", y, "is", z, sep =" ")
}

funSum(1, 3)
funSum("yes",3)
```
What we've done is create a function called `funSum` which takes two numeric inputs `x` and `y`, sums the two into `z` and paste an output telling us the sum. A couple of things to note: 

  - We need to *explicitly* state which arguments are function will take; in this example they are `x` and `y`. Whatever we pass to `x` or `y` will be carried into the function. 
  - We can't sum non-numeric values, so R returns an error in the second instance
  - Functions create their own environment, therefore *any variable* created inside a function only exists inside the function.
    - In the above example, `x`, `y`, and `z` only exist inside the function.
  - R automatically returns whichever variable is on the last line of the body of the function; but you can explicitly ask for an output using `return()`

Let's take a look at a more practical function, something that you might actually use. In mass spectrometry, a gauge of accuracy is the *mass error*, a measure of the difference between the observed and theoretical masses, and is reported in parts-per-million (ppm). The formula for calculating mass error is:

$$ Mass~error~(ppm) = \frac{|mass_{theoretical} - mass_{experimental}|}{mass_{theorical}} \times 10^6 $$

The formula is simple enough, but you may need to calculate any number of mass errors, so it behooves us to compose a quick formula to simplify our workload:


```{r}
ppmMS <- function(theoMZ, expMZ){

  ppm <- abs(theoMZ - expMZ)/theoMZ * 1e6
  ppm
}

# Theoretical mass = 1479.63 m/z
# experimental mass = 1480.10 m/z
ppmMS(theoMZ = 1479.63, expMZ = 1480.10)
```

Pretty useful if you're manually checking something, but we can also use our functions into the pipe to help our data transformation:


```{r}

# Example data
masses <- data.frame("theo" = c(1479.63, 1479.63, 1479.63),
                     "exp" = c(1478.63, 1479.63, 1480.10))

masses %>% 
  mutate(massError = ppmMS(theo, exp))

```

This last part is critical as *functions make your code more legible*. We can clearly read that the code above is calculating the mass error between the theoretical and experimentally observed masses. This might not be as apparent if we put in a complex mathematical formula in the middle of our pipe. 


## Conditional arguments 

Are used to specify a path in a function depending on whether a statement is `TRUE` or `FALSE`. These are explored in greater detail via the links in the [Further Reading] section, but here's a quick example of a function that uses the conditional `if` statement to print out which number is largest: 

```{r}

isGreater <- function(x, y){
  if(x > y){
    return(paste(x, "is greater than", y, sep = " "))
  } else if (x < y){ 
    return(paste(x, "is less than", y, sep = " "))
  }
  return(paste(x, "is equal to", y, sep = " "))
}

isGreater (2, 1)
isGreater (1, 2)
isGreater (1, 1)

```

Our simple function compares two numbers, `x` and `y` and if `x > y` evaluate to `TRUE` it returns the pasted string `x is greater than y`. If `x < y` evaluates to `FALSE`, as in `y > x`, our function returns the pasted string `x is less than y`, and finally if neither `x > y` and `x < y` evaluate to TRUE, they must be equal! Therefore the final output is `x is equal to y`. This is an example of an `else if` statement. If you're simply evaluating two conditions (`TRUE` or `FALSE`) you only need the `if()` conditional, see [Further Reading] for more details. 

### Piping conditional statements

You can already see the potential for simply conditional statements in the pipe. However, to keep piping operations legible, `dplyr` offers the `case_when` function, which works similarly to the `else if` statements showcased above. Let's see how it works using a real world example.

In mass spectrometry undetected compounds are recorded having an intensity of 0; it's a common practice to replace 0 with $\frac{limit~of~detection}{2}$ for subsequent analysys. However, we don't want to replace every value with $\frac{LOD}{2}$, only 0s. Let's use the `case_when()` function to create a new values with the recorded intensities

```{r}

lod <- 4000 # previously calculated LOD 
results <- data.frame("mz" = c(308.97, 380.81, 410.11, 445.34 ), # dummy data
                      "intensities" = c(0, 1000, 5000, 10000)) 

results %>%
  mutate(reportedIntensities = case_when(intensities < lod ~ lod/2,
                                 TRUE ~ intensities))


```


### Piping conditional statements

- case_when 

## When to use functions



###  Tips when using functions
  

## Further Reading

